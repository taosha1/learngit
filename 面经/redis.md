# redis设计与实现
-  字符串
1. redis使用简单动态字符串作为默认字符串表示
2. sds的结构体定义包含len，free和buf字节数组
3. 特点：以常数复杂度获取字符串长度，杜绝缓冲区溢出（在修改字符串前检查是否有足够的空间，不够则自动扩展| <1m 翻倍|>1m +1m），减少内存重分配次数（修改字符串长度n次最多需要执行n次内存重分配,通过未使用空间实现空间预分配和惰性空间释放），二进制安全（除了文本数据外还可以存储二进制数据，因为不以'\0'区分结尾，保证数据在写入和读取是一致的），兼容部分c字符串标准库（达到复用的目的）
- 链表
1. 双端，无环，带表头指针和表尾指针。带链表长度，多态（使用void*保存节点值，存任何类型）
- 字典
1. 字典定义中有了个hash表，在表1rehash时，使用第二个
2. redis先根据type字段的哈希函数计算哈希值随后和sizemask进行位运算，得到索引值
3. redis使用链地址法解决hash冲突
4. rehash，为了维持负载因子（used/size）保持在合理范围，程序会对hash表的大小进行相应的扩展和收缩。步骤如下:1为第二个hash表分配空间，分配的大小取决于第一个表的used字段（2的n次方幂） 2将第一个表的所有键值对放到新表去 3释放表1的空间，将表2交换为表1，新的表2创建为一个空白hash表为下一次rehash做准备
5. 采用渐进式hash，维持一个索引计数器变量rehashidx（-1表示未在rehash状态）。程序除了执行指定操作外还会顺带将索引所指向的所有键值对rehash到表2.当rehash完成时，将计算器设置为-1。这种方式采取了分而治之的思想，将庞大的计算工作分摊到对字典的每个crud操作上，避免了集中式rehash的性能影响。
6. 在这个过错中，查找删除更新等操作会在两个表上进行，但是添加操作会直接在表2进行，保证表1的键值对数量只减不增。
- 跳跃表
1. 跳跃表是一种有序数据结构，他通过在每个节点中维持多个指向其他节点的指针达到快速访问节点的目的。平均O(logN)最坏O(N)复杂度。
2. redis使用跳跃表作为有序集合键的底层实现
- 整数集合
1. 整数集合是集合键的底层实现之一。当一个集合仅包括整数值元素，且个数不多时使用。
2. contents数组的真正类型取决于encoding属性。各个项在数组中按值的大小有序排列，且不含重复项
3. 当向一个集合添加一个新元素且类型更长，整数集合会进行升级，分为三步，1）根据新元素类新，扩展整数集合底层数组的空间大小，并分配空间给新元素2）将底层数据的各项类型转换为新元素的类型，放到正确的位上，维持有序性3）添加新元素修改length属性。
4. 升级的好处1）提升灵活性随意添加不同类型的整数，不必担心类型错误2）节省内存，只在需要时升级3）不支持降级 编码不会变得更小
- 压缩列表
1. 当列表键要么是小整数，要么是长度短的字符串时，采用压缩列表作为底层实现。
2. 一个压缩列表可以包含任意多个entry，每个entry可以是一个字节数组或一个整数值
3. 压缩列表的组成部分包括1）占用字节数用于调整空间大小，内存重分配2）指向尾节点的偏移量3）节点数量4）多个entry的内容5）标记列表的末端
4. entry的组成：1）前一个节点的长度（1或者5字节）2）encoding属性记录类型和长度3）content记录节点内容
5. 连锁更新：在特殊情况下，添加或删除节点后会引发相关联的节点信息的连锁更新。但是产生这种情况的几率很低，必须恰好有连续多个长度介于250字节至253字节的节点
- 对象
1. redis没有直接使用这些数据结构，而是基于这些创建了一个对象系统。好处在于为对象设置不同的数据结构实现，优化对象在不同场景的使用效率，此外还实现了基于引用计数的内存回收机制，达到了自动回收内存和实现对象的共享机制。最后还有访问时间记录信息，用于计算键的空转时长。
2. 对象的类型和编码：type属性记录了对象的类型，包含5种2）对象的ptr指针指向对象的底层实现数据结构，这些结构由encoding属性决定
3. string对象：int raw embstr，raw和embstr的区别，embstr编码是短字符串的一种优化编码方式<=32字节。
4. 多态命令：redis根据对象的type 决定键是否能够执行指定命令，还会根据编码方式选择正确的命令来实现如获取列表的长度。DEL是基于类型的多态，而LLEN是基于编码的多态
5. 对象共享refcount
6. 对象空转时长lru属性记录了对象最后一次被命令程序访问的时间
## part2 单机数据库的实现
1. 初始化服务器时，会根据服务器状态的dbnum属性来决定创建多少个数据库，使用SELECT 来切换目标数据库。客户端状态redisClient结构的db属性记录了当前的目标数据库
2. 数据库键空间：redisDb结构的dict字典保存了数据库中所有的键值对，这个字典称为key space ，键空间与用户所见的数据库直接对应
3. 读写键空间的维护操作：1）读取键后根据键是否存在更新hti和miss次数2）更新键的lru时间3）读取键时，发现键过期，先删除然后执行余下的其他操作。4）使用watch命令监视某个键，对其进行修改会将这个键的标记为脏。5）每修改一个键后，对脏键计数器+1，这个计数器会触发db的持久化和复制操作。
4. 通过EXPIRE或者PEXPIRE命令可以以秒或毫秒精度为某个键设置生存周期ttl。
5. 保存过期时间：redisDb的expires字典保存了数据库中所有键的过期时间，又称这个字典为过期字典。键为指向某个键对象的指针，值是一个unix时间戳
6. 过期键的删除策略：定时（每隔一段时间检查一次）删除，惰性删除，定时(立即删除过期键)删除。内存友好，cpu时间友好两个角度
7. 执行save或者bgsave命令时创建一个新的rdb文件，redis会对键进行检查，已过期的键不会被保存。AOF持久化时，当键已经过期但还没有被删除，aof文件不会因为这个过期键而产生任何影响。被删除后，会向aof文件追加一条del命令来显示记录。
8. 键空间通知，键事件通知
- rdb持久化
- aof持久化
- 事件
- 客户端
- 服务器
## part3 多机数据库实现
-  复制
1. 旧版复制功能的实现和缺陷
2. 通过执行slaveof 实现主从服务器之间的复制，分为同步sync和命令传播两个操作。将对主数据库的写命令，发送给从服务器执行达到一致性状态。缺陷：在断线后重复制效率低
3. 新版复制功能使用psync命令代替sync命令来执行复制时的同步操作。psync具有完整重同步，部分重同步。用于初次和断线后重连情况。
4. 部分重同步功能由三个部分构成：1复制偏移量2复制积压缓冲区3服务器运行id
- 哨兵
1. 哨兵是高可用的解决方案，哨兵系统可以监视任意多个主服务器及从服务器，并选拔新的主服务器
- 集群